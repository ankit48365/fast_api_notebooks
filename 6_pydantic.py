# Data Model with Pydantic
# When a function definition has many parameters, it becomes very clumsy to pass that many arguments while calling. In the previous section, we defined the addnew() function with four Body parameters (prodID, prodName, price, and stock). In some other scenario, it could be more.
# A workaround could be to declare a class (say Product) having properties as before and use its object as the parameter. However, it gives rise to another problem of validating the parameter values before processing them inside the function.
# The Pydantic library addresses exactly the same problem. As we mentioned previously in the first chapter, Pydantic is a data modeling, validation, and parsing library. FastAPI makes extensive use of Pydantic, such as declaring the data model for populating the HTTP request body and efficiently performing CRUD operations on the databases (both SQL and NoSQL types).

# dataclasses Module
# At the center of the power of the Pydantic library is the BaseModel class. In a way, it is similar to the dataclasses library introduced in Python’s standard library from version 3.7 onward.
# The object of a Python class becomes a data container when decorated by the @dataclass decorator. It autogenerates the __init__() constructor for the user’s class and also inserts the __repr__() method for the string representation of the object.
# The Product class decorated by the @dataclass is declared as in Listing 3-4. Since there’s an autogenerated constructor and string representation method in place, we can declare the object.

# Listing 3-4:
# from dataclasses import dataclass
# @dataclass
# class Product:
#     prodId:int
#     prodName:str
#     price:float
#     stock:int
# p1=Product(1, "Ceiling Fan", 2000, 50)
# print (p1)

# The @dataclass decorator also generates the magic methods like __eq__() for implementing Boolean operators and provides the dict as well as tuple representation of the class properties with asdict() and astuple() methods.
# However, the dataclasses module doesn’t have the mechanism of data validation. Hence, it is not possible to enforce schema constraints on the object data during runtime.
# This is where Pydantic’s BaseModel class comes into the picture.

# BaseModel
# At the center of the Pydantic library’s functionality is the BaseModel class. A class that uses BaseModel as its parent works as a data container, just as a dataclass. Additionally, we can apply certain customized validation criteria on the properties of the class.
# Listing 3-5 shows the basic usage of BaseModel. Let's declare the Product model, based on the BaseModel.

# Listing 3-5:
# from pydantic import BaseModel

# class Product(BaseModel):
#     prodId:int
#     prodName:str
#     price:float
#     stock:int

# This class inherits the schema_json() method from BaseModel that renders its JSON representation, as shown in Listing 3-6.

# Listing 3-6:
# {
#   "title": "Product",
#   "type": "object",
#   "properties": {
#     "prodId": {
#       "title": "Prodid",
#       "type": "integer"
#     },
#     "prodName": {
#       "title": "Prodname",
#       "type": "string"
#     },
#     "price": {
#       "title": "Price",
#       "type": "number"
#     },
#     "stock": {
#       "title": "Stock",
#       "type": "integer"
#     }
#   },
#   "required": [
#     "prodId",
#     "prodName",
#     "price",
#     "stock"
#   ]
# }

# Before we explore the validation feature of Pydantic, let us see how it influences the FastAPI code.

# Pydantic Model As Parameter
# Let us declare a parameter of Product type in the addnew() operation function in the FastAPI code. Look at the script in Listing 3-7.

# Listing 3-7:
# from fastapi import FastAPI
# from pydantic import BaseModel

# class Product(BaseModel):
#     prodId:int
#     prodName:str
#     price:float
#     stock:int

# app = FastAPI()
# @app.post("/product/")
# async def addnew(product:Product):
#     return product

# The moment FastAPI finds that the operation function has a Pydantic model parameter, the request body is populated by the properties in the model class – in our case, the Product class. The class specifications also help Swagger UI to generate the Product schema. Figure 3-2 shows the schema part of the documentation.
# Figure 3-2: Product schema in Swagger
# Larger View

# Typically, the POST method is used to add a new resource in the collection. Let us therefore maintain a list (productlist) of all the Product objects, as done in Listing 3-8. Every time the POST operation is done, the object is appended in the list. Accordingly, we need to modify the definition of the addnew() operation function.
# Listing 3-8:
# productlist=[]

# @app.post("/product/")
# async def addnew(product:Product):
#     productlist.append(product)
#     return productlist

# Add a couple of Product objects using the web interface of Swagger UI and check the server’s response which looks as in Figure 3-3.

# Figure 3-3: Server response with the Pydantic model
# Larger View

# Once the model is passed, its attributes can be accessed and modified inside the operation function. Here, we would like to apply a tax of 10% on the price if it is greater than 5000. Listing 3-9 shows how the addnew() function modifies the price attribute.

# Listing 3-9:
# @app.post("/product/")
# async def addnew(product:Product):
#     dct=product.dict()
#     price=dct['price']
#     if price>5000:
#         dct['price']=price+price*0.1
#         product.price=dct['price']
#     productlist.append(product)
#     return productlist


from fastapi import FastAPI
from pydantic import BaseModel

class Product(BaseModel):
    prodId:int
    prodName:str
    price:float
    stock:int

################################################
# Example 1 showing simple single product return

# app = FastAPI()
# @app.post("/product/")
# async def addnew(product:Product):
#     return product

#  CLI: uvicorn 6_pydantic:app --reload


################################################
# Example 2 showing product list return

productlist=[]
app = FastAPI()
@app.post("/product/")
async def addnew(product:Product):
    productlist.append(product)
    return productlist

#  CLI: uvicorn 6_pydantic:app --reload

################################################
# Example 3 showing product list return along with new column added on a condition


# productlist=[]
# app = FastAPI()
# @app.post("/product/")
# async def addnew(product:Product):
#     dct=product.dict()
#     price=dct['price']
#     if price>5000:
#         dct['price']=price+price*0.1
#         product.price=dct['price']
#     productlist.append(product)
#     return productlist

#  CLI: uvicorn 6_pydantic:app --reload
